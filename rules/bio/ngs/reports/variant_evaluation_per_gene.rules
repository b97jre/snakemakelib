# -*- snakemake -*-
import os
import glob
import math
from snakemakelib.config import update_sml_config, sml_rules_path, get_sml_config
from snakemakelib.report.picard import qc_plots

# Start by including the general snakefile
include: os.path.join(sml_rules_path(), 'bio/ngs', 'settings.rules')
# Include required gatk rules
include: os.path.join(sml_rules_path(), 'bio/ngs/tools', 'samtools.rules')
include: os.path.join(sml_rules_path(), 'bio/ngs/tools', 'bedtools.rules')
include: os.path.join(sml_rules_path(), 'bio/ngs/qc', 'picard.rules')

sml_config = get_sml_config()

config_default = {
    'bio.ngs.reports.variant_evaluation_per_gene' : {
        'reportdir' : 'report',
        'graphicsdir' : 'report/grf',
        'project_name' : '',
        'application' : '',
    },
}

update_sml_config(config_default)

cfg = get_sml_config()
settings_cfg = sml_config['bio.ngs.settings']
samtools_cfg = sml_config['bio.ngs.tools.samtools']
bedtools_cfg = sml_config['bio.ngs.tools.bedtools']
picard_cfg = sml_config['bio.ngs.qc.picard']
report_cfg = sml_config['bio.ngs.reports.variant_evaluation_per_gene']

rule variant_evaluation_per_gene_overlapping_baits:
    """Generate overlapping bed file for bait definition file"""
    params: cmd=os.path.join(bedtools_cfg['home'], bedtools_cfg['intersectbed']['cmd']),
            options = bedtools_cfg['intersectbed']['options']
    input: a="{prefix}.{gene}.bed", b=bedtools_cfg['sequence_capture']['bait_regions']
    output: "{prefix}.{gene}.baits.bed"
    shell: "{params.cmd} -a {input.a} -b {input.b} > {output}"

rule variant_evaluation_per_gene_overlapping_targets:
    """Generate overlapping bed file for target definition file"""
    params: cmd=os.path.join(bedtools_cfg['home'], bedtools_cfg['intersectbed']['cmd']),
            options = bedtools_cfg['intersectbed']['options']
    input: a="{prefix}.{gene}.bed", b=bedtools_cfg['sequence_capture']['target_regions']
    output: "{prefix}.{gene}.targets.bed"
    shell: "{params.cmd} -a {input.a} -b {input.b} > {output}"

rule variant_evaluation_per_gene_picard_hs_metrics:
    """Run picard hsmetrics on a specific region"""
    params: cmd = picard_config['cmd'] + CALCULATE_HS_METRICS,
            options = picard_config['options']
    input: bam = "{prefix}.{gene}.bam", targets="{prefix}.{gene}.targets.interval_list", baits="{prefix}.{gene}.baits.interval_list", ref=picard_config['ref']
    output: "{prefix}.{gene}.hs_metrics"
    shell: "{params.cmd} {params.options} TI={input.targets} BI={input.baits} I={input.bam} O={output} R={input.ref}"

rule variant_evaluation_per_gene_picard_create_interval_list_awk:
    """Variant Evaluation, Picard: create interval list using awk"""
    params: cmd = picard_config['cmd'] + CREATE_SEQUENCE_DICTIONARY,
            options = picard_config['options']
    input: bed="{prefix}.{gene}.bed", dict=picard_config['ref'].replace(".fa", ".dict")
    output: "{prefix}.{gene}.interval_list"
    shell: cfg['comp.settings']['cat'] + " {input.dict} > {output}; " + cfg['comp.settings']['awk'] + " '{{printf(\"%s\\t%s\\t%s\\t%s\\t%s\\n\", $1,$2,$3,\"+\",$4); FS=\"\t\"}}' {input.bed} >> {output}"

ruleorder: variant_evaluation_per_gene_picard_create_interval_list_awk > picard_create_interval_list_awk

rule variant_evaluation_per_gene_picard_qc_report:
    """Generate gene-based picard report"""
    input: align_metrics="{prefix}.{gene}.dup.align_metrics", insert_metrics="{prefix}.{gene}.dup.insert_metrics", dup_metrics="{prefix}.{gene}.dup_metrics", hs_metrics="{prefix}.{gene}.dup.hs_metrics"
    output: report = os.path.join(report_cfg['reportdir'], "{prefix}.{gene}_picard_qc.html"),
            seqstats = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.seqstats.png'),
            alnmet = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.alnmet.png'),
            dupmet = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.dupmet.png'),
            insmet = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.insmet.png'),
            targetmet = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.targetmet.png'),
            target2dup = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.target2dup.png'),
            hsmet = os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.hsmet.png'),
            hsmetsub = [os.path.join(report_cfg['graphicsdir'], '{prefix}.{gene}.hsmetsub-' + str(x) + '.png') for x in range(0, math.ceil(len(cfg['bio.ngs.settings']['samples'])/9))],
            metricstable = os.path.join(report_cfg['reportdir'], '{prefix}.{gene}.picardmetrics.csv'),
            summarytable = os.path.join(report_cfg['reportdir'], '{prefix}.{gene}.picardmetricssummary.csv')

    run:
        samples = cfg['bio.ngs.settings']['samples']
        print (list(input))
        # qc_plots(list(input), samples, report_cfg, output)
        kw = {
            'project_name' : report_cfg['project_name'],
            'application' : report_cfg['application'],
            'region' : wildcards.gene,
        }
        # reportdir = report_cfg['reportdir'] + os.sep if not report_cfg['reportdir'].endswith(os.sep) else report_cfg['reportdir']
        # d = dict(rules.report_generate_qc_plots.output.items())
        # i = 0
        # for x in d['hsmetsub']:
        #     d['hsmetsub_' + str(i)] = x
        #     i += 1
        # kw.update ([(k, str(v).replace(reportdir, '')) for k,v in d.items()])
        # kw['hsmetsub'] = kw['hsmetsub'].split(" ")
        # s = picard_qc_report.render(**kw)
        # del d['hsmetsub']
        # report(s, str(output), **d)

